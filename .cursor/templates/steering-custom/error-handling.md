# エラーハンドリング標準

[目的: エラーの分類、形状、伝播、ロギング、監視方法を統一]

## 哲学
- 可能な限り早期に失敗。システム境界ではグレースフルに低下
- スタック全体で一貫したエラー形状（人間 + マシン可読）
- 既知のエラーはソース近くで処理。未知のエラーはグローバルハンドラーへ

## 分類（ソースによって処理を決定）
- クライアント: 入力/検証/ユーザーアクションの問題 → 4xx
- サーバー: システム障害/予期しない例外 → 5xx
- ビジネス: ルール/状態違反 → 4xx（例: 409）
- 外部: サードパーティ/ネットワーク障害 → コンテキスト付きで5xxまたは4xxにマッピング

## エラー形状（単一の正規形式）
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "人間可読メッセージ",
    "requestId": "trace-id",
    "timestamp": "ISO-8601"
  }
}
```
原則: 安定したコード列挙、シークレットなし、トレース情報を含める。

## 伝播（どこで変換するか）
- APIレイヤー: ドメインエラーをHTTPステータス + 正規ボディに変換
- サービスレイヤー: 型付きビジネスエラーをスロー、文字列ベースのエラーを避ける
- データ/外部レイヤー: プロバイダーエラーを安全でアクション可能なコードでラップ
- 未知のエラー: グローバルハンドラーにバブル → 500 + 汎用メッセージ

パターン例:
```typescript
try { return await useCase(); }
catch (e) {
  if (e instanceof BusinessError) return respondMapped(e);
  logError(e); return respondInternal();
}
```

## ロギング（ノイズよりコンテキスト）
ログ: 操作、userId（利用可能な場合）、コード、メッセージ、スタック、requestId、最小限のコンテキスト。
ログしない: パスワード、トークン、シークレット、完全なPII、機密データを含む完全なボディ。
レベル: ERROR（障害）、WARN（回復可能/エッジ）、INFO（主要イベント）、DEBUG（診断）。

## リトライ（安全な場合のみ）
リトライする場合: ネットワーク/タイムアウト/一時的な5xx かつ 操作が冪等。
リトライしない: 4xx、ビジネスエラー、非冪等フロー。
戦略: 指数バックオフ + ジッター、上限付き試行回数。冪等性キーを要求。

## 監視 & ヘルス
追跡: コード/カテゴリ別のエラー率、レイテンシ、飽和度。スパイク/SLI違反でアラート。
ヘルスを公開: `/health`（ライブ）、`/health/ready`（レディ）。エラーをトレースにリンク。

---
_パターンと決定事項に焦点を当てる。実装詳細や網羅的なリストは含まない。_
