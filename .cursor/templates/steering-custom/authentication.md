# 認証・認可標準

[目的: 認証モデル、トークン/セッションライフサイクル、権限チェック、セキュリティを統一]

## 哲学
- 明確な分離: 認証（誰か）vs 認可（何ができるか）
- デフォルトでセキュア: 最小権限、クローズドで失敗、短命トークン
- UX重視: リスクが高い場所では摩擦、それ以外はスムーズに

## 認証

### 方式（選択 + 根拠）
- オプション: JWT、セッション、OAuth2、ハイブリッド
- 選択: [選んだ方式] 理由: [理由]

### フロー（概要）
```
1) ユーザーが身元を証明（認証情報またはプロバイダー）
2) サーバーが検証しトークン/セッションを発行
3) クライアントがリクエストごとにトークンを送信
4) サーバーがトークンを検証し処理を続行
```

### トークン/セッションライフサイクル
- ストレージ: httpOnlyクッキーまたはAuthorizationヘッダー
- 有効期限: 短命のアクセストークン、長めのリフレッシュ（使用する場合）
- リフレッシュ: トークンをローテーション。失効を尊重
- 失効: ログアウト/侵害時にブラックリスト/ローテーション

### セキュリティパターン
- TLSを強制。可能な限りトークンをJSに公開しない
- トークンをオーディエンス/発行者にバインド。最小限のクレームを含める
- 機密アクションにはデバイスバインディングとIP/リスクチェックを検討

## 認可

### 権限モデル
- 1つを選択: RBAC / ABAC / 所有権ベース / ハイブリッド
- ロール/属性を中央で定義。コードベース全体でのハードコーディングを避ける

### チェック（どこで強制するか）
- ルート/ミドルウェア: 粗粒度のゲート
- ドメイン/サービス: 細粒度の決定
- UI: 条件付きレンダリング（セキュリティに依存しない）

パターン例:
```typescript
requirePermission('resource:action'); // ルート
if (!user.can('resource:action')) throw ForbiddenError(); // ドメイン
```

### 所有権
- パターン: 所有者または特権ロールがアクション可能
- 変更前にエンティティ境界で検証

## パスワード & MFA
- パスワード: 強力なポリシー、ハッシュ化（bcrypt/argon2）、決してプレーンテキストにしない
- リセット: 時間制限トークン、使い捨て、ユーザーに通知
- MFA: リスクの高い操作でステップアップ（ポリシー駆動）

## API間認証
- APIキーまたはOAuthクライアントクレデンシャルを使用
- キーのスコープを最小限に。ローテーションと使用監査
- アイデンティティ（ユーザー/キー）でレート制限

---
_パターンと決定事項に焦点を当てる。ライブラリ固有のコードは含まない。_
