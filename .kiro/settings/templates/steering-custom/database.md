# データベース標準

[目的: スキーマ設計、クエリ、マイグレーション、整合性をガイド]

## 哲学
- まずドメインをモデル化。正確性の後に最適化
- 明示的な制約を優先。データベースに不変条件を強制させる
- 必要なものだけクエリ。最適化前に計測

## 命名 & 型
- テーブル: `snake_case`、複数形 (`users`, `order_items`)
- カラム: `snake_case` (`created_at`, `user_id`)
- FK: `{table}_id` が `{table}.id` を参照
- 型: タイムゾーン対応タイムスタンプ。強い型のID。正確な金額型

## リレーションシップ
- 1:N: 子にFK
- N:N: 複合キーの結合テーブル
- 1:1: FK + UNIQUE

## マイグレーション
- イミュータブルなマイグレーション。常にロールバックを追加
- 小さく焦点を絞ったステップ。本番以外で先にテスト
- 命名: `{seq}_{action}_{object}` (例: `002_add_email_index`)

## クエリパターン
- 単純なCRUDと安全性にはORM。複雑/パフォーマンス重視には生SQL
- N+1を避ける（Eagerロード/バッチ処理）。大きなセットはページネーション
- FKと頻繁にフィルタ/ソートされるカラムにインデックス

## コネクション & トランザクション
- プーリングを使用（ワークロードに基づいてサイズ/タイムアウト）
- 作業単位ごとに1コネクション。迅速にクローズ/返却
- 複数ステップの変更をトランザクションでラップ

## データ整合性
- NOT NULL/UNIQUE/CHECK/FK制約を使用
- 適切な場合はDBで検証（多層防御）
- 一貫した派生には生成カラムを優先

## バックアップ & リカバリ
- 保持期間付きの定期バックアップ。復元をテスト
- RPO/RTO目標を文書化。バックアップジョブを監視

---
_パターンと決定事項に焦点を当てる。環境固有の設定は含まない。_
